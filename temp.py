#!/usr/bin/env python3
"""
VEGA - Verification Environment Generator Assembler
Version: 5.0.0 (Unificado)

Features:
- Suporte integrado para testes unit√°rios e sist√™micos
- An√°lise hier√°rquica autom√°tica
- Plano de verifica√ß√£o configur√°vel
- Templates adapt√°veis para RISC-V e designs gen√©ricos
"""

import os
import re
import sys
import math
import json
import zipfile
from datetime import datetime
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple
from pathlib import Path
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
from jinja2 import Environment, FileSystemLoader, TemplateNotFound
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# ---------------------------------------------------------------
# Estruturas de Dados Estendidas
# ---------------------------------------------------------------
@dataclass
class VerificationPlan:
    """Configura√ß√£o completa do plano de verifica√ß√£o"""
    unit_tests: Dict[str, bool] = field(default_factory=lambda: {
        'functional': True,
        'edge_cases': True,
        'reset_tests': True
    })
    system_tests: Dict[str, bool] = field(default_factory=lambda: {
        'interface_consistency': True,
        'dataflow': True,
        'performance': False,
        'concurrency': False
    })
    coverage_goals: Dict[str, int] = field(default_factory=lambda: {
        'line': 90,
        'toggle': 80,
        'fsm': 95,
        'assertion': 85
    })
    test_weights: Dict[str, int] = field(default_factory=lambda: {
        'smoke': 30,
        'random': 50,
        'stress': 20
    })
    custom_checks: List[str] = field(default_factory=list)

@dataclass 
class Port:
    """Porta RTL com extens√µes para an√°lise sist√™mica"""
    name: str
    direction: str
    width: str = "1"
    protocol: Optional[str] = None  # e.g., AXI, APB, etc.
    connected_to: Optional[str] = None
    timing: Optional[Dict] = None

@dataclass
class ModuleInfo:
    """Informa√ß√µes estendidas do m√≥dulo"""
    name: str
    ports: List[Port] = field(default_factory=list)
    parameters: Dict[str, str] = field(default_factory=dict)
    instances: Dict[str, str] = field(default_factory=dict)
    is_top: bool = False
    domain: Optional[str] = None  # cpu, mem, peripheral, etc.

@dataclass
class DesignHierarchy:
    """Hierarquia completa do design"""
    top_module: ModuleInfo
    submodules: Dict[str, ModuleInfo]
    connections: List[Tuple[str, str, str, str]]  # (mod1, port1, mod2, port2)
    clock_domains: Dict[str, List[str]]
    timing_constraints: Dict[str, Dict]

# ---------------------------------------------------------------
# N√∫cleo do Analisador RTL
# ---------------------------------------------------------------
class RTLAnalyzer:
    """Analisador estendido para suporte hier√°rquico"""
    
    PROTOCOLS = {
        'AXI': {'signals': ['valid', 'ready', 'data'], 'rules': [...]},
        'APB': {'signals': ['psel', 'penable', 'pwrite'], 'rules': [...]},
        'Wishbone': {'signals': ['cyc', 'stb', 'ack'], 'rules': [...]}
    }

    @classmethod
    def analyze_project(cls, project_path: str) -> DesignHierarchy:
        """Analisa um projeto completo"""
        modules = cls._discover_modules(project_path)
        top = cls._identify_top_module(modules)
        connections = cls._extract_connections(top, modules)
        clock_domains = cls._analyze_clock_domains(top, modules)
        
        return DesignHierarchy(
            top_module=top,
            submodules=modules,
            connections=connections,
            clock_domains=clock_domains,
            timing_constraints=cls._extract_timing_constraints(top)
        )

    @classmethod
    def _discover_modules(cls, project_path: str) -> Dict[str, ModuleInfo]:
        """Descobre todos os m√≥dulos no projeto"""
        modules = {}
        for file in Path(project_path).rglob('*.[svv]'):
            try:
                content = cls._read_file(file)
                module = cls._extract_module_info(content)
                modules[module.name] = module
            except ValueError as e:
                continue
        return modules

    @classmethod
    def _extract_module_info(cls, content: str) -> ModuleInfo:
        """Extrai informa√ß√µes detalhadas do m√≥dulo"""
        # Implementa√ß√£o similar √† vers√£o anterior, mas com:
        # - Detec√ß√£o de protocolos
        # - An√°lise de dom√≠nios de clock
        # - Identifica√ß√£o de interfaces padr√£o
        pass

    @classmethod
    def _identify_top_module(cls, modules: Dict[str, ModuleInfo]) -> ModuleInfo:
        """Identifica o m√≥dulo top-level"""
        # Implementa√ß√£o similar √† vers√£o anterior
        pass

    @classmethod
    def _extract_connections(cls, top: ModuleInfo, modules: Dict[str, ModuleInfo]) -> List[Tuple]:
        """Extrai conex√µes hier√°rquicas"""
        connections = []
        for inst_name, mod_name in top.instances.items():
            if mod_name in modules:
                for port in modules[mod_name].ports:
                    if port.connected_to:
                        connections.append(
                            (mod_name, port.name, 
                             port.connected_to.split('.')[0], 
                             port.connected_to.split('.')[1])
        return connections

    @classmethod
    def _analyze_clock_domains(cls, top: ModuleInfo, modules: Dict[str, ModuleInfo]) -> Dict:
        """Identifica dom√≠nios de clock no design"""
        clock_domains = defaultdict(list)
        for inst_name, mod_name in top.instances.items():
            if mod_name in modules:
                mod = modules[mod_name]
                for port in mod.ports:
                    if 'clk' in port.name.lower():
                        clock_domains[port.connected_to].append(mod_name)
        return dict(clock_domains)

# ---------------------------------------------------------------
# Interface Gr√°fica Atualizada
# ---------------------------------------------------------------
class UVMAutoGenerator:
    def __init__(self, root):
        self.root = root
        self.root.title("VEGA v5.0.0")
        self.root.geometry("1400x900")
        
        # Estado do sistema
        self.design_hierarchy = None
        self.verification_plan = VerificationPlan()
        self.current_mode = tk.StringVar(value="unit")  # "unit" or "system"
        
        # Configura√ß√£o da interface
        self._setup_menus()
        self._setup_main_interface()
        self._setup_verification_plan_tab()
        self._setup_template_environment()
        
    def _setup_menus(self):
        """Configura a barra de menus estendida"""
        menubar = tk.Menu(self.root)
        
        # Menu Arquivo
        file_menu = tk.Menu(menubar, tearoff=0)
        file_menu.add_command(label="Abrir Projeto", command=self.load_project)
        file_menu.add_command(label="Exportar Plano de Verifica√ß√£o", command=self.export_plan)
        file_menu.add_separator()
        file_menu.add_command(label="Sair", command=self.root.quit)
        menubar.add_cascade(label="Arquivo", menu=file_menu)
        
        # Menu Verifica√ß√£o
        verify_menu = tk.Menu(menubar, tearoff=0)
        verify_menu.add_radiobutton(label="Modo Unit√°rio", variable=self.current_mode, value="unit")
        verify_menu.add_radiobutton(label="Modo Sist√™mico", variable=self.current_mode, value="system")
        menubar.add_cascade(label="Verifica√ß√£o", menu=verify_menu)
        
        self.root.config(menu=menubar)
    
    def _setup_main_interface(self):
        """Configura a interface principal com notebook"""
        self.notebook = ttk.Notebook(self.root)
        
        # Abas principais
        self._init_welcome_tab()
        self._init_project_tab()
        self._init_verification_plan_tab()
        self._init_config_tab()
        self._init_results_tab()
        
        self.notebook.pack(expand=True, fill='both')
    
    def _setup_verification_plan_tab(self):
        """Nova aba para configura√ß√£o do plano de verifica√ß√£o"""
        self.plan_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.plan_tab, text="üìã Plano de Verifica√ß√£o")
        
        # Frame de configura√ß√£o
        config_frame = ttk.LabelFrame(self.plan_tab, text="Estrat√©gia de Verifica√ß√£o", padding=10)
        config_frame.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Seletor de modo
        mode_frame = ttk.Frame(config_frame)
        mode_frame.pack(fill='x', pady=5)
        ttk.Label(mode_frame, text="Tipo de Verifica√ß√£o:").pack(side='left')
        ttk.Combobox(mode_frame, textvariable=self.current_mode, 
                    values=["unit", "system"], state="readonly").pack(side='left', padx=10)
        
        # Notebook para configura√ß√µes espec√≠ficas
        plan_notebook = ttk.Notebook(config_frame)
        
        # Aba para testes unit√°rios
        unit_tab = ttk.Frame(plan_notebook)
        self._setup_unit_test_plan(unit_tab)
        plan_notebook.add(unit_tab, text="Testes Unit√°rios")
        
        # Aba para testes sist√™micos
        sys_tab = ttk.Frame(plan_notebook)
        self._setup_system_test_plan(sys_tab)
        plan_notebook.add(sys_tab, text="Testes Sist√™micos")
        
        # Aba para cobertura
        cov_tab = ttk.Frame(plan_notebook)
        self._setup_coverage_plan(cov_tab)
        plan_notebook.add(cov_tab, text="Metas de Cobertura")
        
        plan_notebook.pack(fill='both', expand=True)
    
    def _setup_unit_test_plan(self, parent):
        """Configura o painel de testes unit√°rios"""
        checks = [
            ("Testes Funcionais B√°sicos", "unit_tests.functional"),
            ("Casos de Borda", "unit_tests.edge_cases"),
            ("Testes de Reset", "unit_tests.reset_tests"),
            ("Verifica√ß√£o de Par√¢metros", "unit_tests.param_checks")
        ]
        
        for text, var_path in checks:
            var = self._get_nested_var(self.verification_plan, var_path)
            ttk.Checkbutton(parent, text=text, variable=var).pack(anchor='w', pady=2)
    
    def _setup_system_test_plan(self, parent):
        """Configura o painel de testes sist√™micos"""
        # Verifica√ß√µes de integra√ß√£o
        int_frame = ttk.LabelFrame(parent, text="Verifica√ß√µes de Integra√ß√£o", padding=10)
        int_frame.pack(fill='x', pady=5)
        
        int_checks = [
            ("Consist√™ncia de Interfaces", "system_tests.interface_consistency"),
            ("Fluxo de Dados", "system_tests.dataflow"),
            ("Acesso Concorrente", "system_tests.concurrency")
        ]
        
        for text, var_path in int_checks:
            var = self._get_nested_var(self.verification_plan, var_path)
            ttk.Checkbutton(int_frame, text=text, variable=var).pack(anchor='w', pady=2)
        
        # Verifica√ß√µes de desempenho
        perf_frame = ttk.LabelFrame(parent, text="Verifica√ß√µes de Desempenho", padding=10)
        perf_frame.pack(fill='x', pady=5)
        
        perf_checks = [
            ("Lat√™ncia M√°xima", "system_tests.performance"),
            ("Vazamento de Dados", "system_tests.data_integrity")
        ]
        
        for text, var_path in perf_checks:
            var = self._get_nested_var(self.verification_plan, var_path)
            ttk.Checkbutton(perf_frame, text=text, variable=var).pack(anchor='w', pady=2)
    
    def _setup_coverage_plan(self, parent):
        """Configura o painel de metas de cobertura"""
        metrics = [
            ("Cobertura de Linha", "coverage_goals.line"),
            ("Cobertura de Toggle", "coverage_goals.toggle"),
            ("Cobertura FSM", "coverage_goals.fsm"),
            ("Cobertura de Assertivas", "coverage_goals.assertion")
        ]
        
        for text, var_path in metrics:
            frame = ttk.Frame(parent)
            frame.pack(fill='x', pady=2)
            
            ttk.Label(frame, text=text, width=25).pack(side='left')
            var = self._get_nested_var(self.verification_plan, var_path)
            ttk.Spinbox(frame, from_=0, to=100, textvariable=var, width=5).pack(side='left')
            ttk.Label(frame, text="%").pack(side='left', padx=5)

# ---------------------------------------------------------------
# Templates Atualizados
# ---------------------------------------------------------------
"""
Os templates foram organizados em uma estrutura de diret√≥rios:

templates/
‚îú‚îÄ‚îÄ unit/               # Testes unit√°rios
‚îÇ   ‚îú‚îÄ‚îÄ interface.sv.j2
‚îÇ   ‚îú‚îÄ‚îÄ transaction.sv.j2
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ system/            # Testes sist√™micos
‚îÇ   ‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interface_consistency.sv.j2
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dataflow.sv.j2
‚îÇ   ‚îú‚îÄ‚îÄ performance/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ latency_check.sv.j2
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ throughput.sv.j2
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ common/            # Componentes compartilhados
    ‚îú‚îÄ‚îÄ coverage.sv.j2
    ‚îî‚îÄ‚îÄ reporting.sv.j2
"""

# Template de exemplo para verifica√ß√£o sist√™mica
SYSTEM_INTERFACE_TEMPLATE = """// Interface sist√™mica para {{module.name}}
// Gerado automaticamente em {{timestamp}}

interface {{module.name}}_system_if;
    // Conex√µes para todos os submodules
    {% for submod in hierarchy.submodules.values() %}
    {{submod.name}}_if {{submod.name}}_if();
    {% endfor %}
    
    // Modports para diferentes agentes
    modport controller_mp(
        // Conex√µes de controle
    );
    
    modport monitor_mp(
        // Conex√µes de monitoramento
        {% for submod in hierarchy.submodules.values() %}
        .{{submod.name}}_monitor({{submod.name}}_if.monitor),
        {% endfor %}
    );
endinterface
"""

# Template de exemplo para scoreboard sist√™mico
SYSTEM_SCOREBOARD_TEMPLATE = """// Scoreboard sist√™mico para {{top_name}}
// Gerado automaticamente em {{timestamp}}

class {{top_name}}_system_scoreboard extends uvm_scoreboard;
    // An√°lise de subsistemas
    {% for submod in hierarchy.submodules.values() %}
    {{submod.name}}_analyzer {{submod.name}}_analyzer;
    {% endfor %}
    
    // Verifica√ß√µes cruzadas
    function void check_cross_module_consistency();
        {% if plan.system_tests.interface_consistency %}
        // Verifica√ß√£o de protocolos entre m√≥dulos
        check_interface_protocols();
        {% endif %}
        
        {% if plan.system_tests.dataflow %}
        // Verifica√ß√£o de fluxo de dados
        check_data_integrity();
        {% endif %}
    endfunction
    
    {% if plan.system_tests.performance %}
    // An√°lise de desempenho
    function void check_performance();
        // Implementa√ß√£o das verifica√ß√µes
    endfunction
    {% endif %}
endclass
"""

# ---------------------------------------------------------------
# Gera√ß√£o de C√≥digo Atualizada
# ---------------------------------------------------------------
class UVMGenerator:
    """Classe unificada para gera√ß√£o de c√≥digo"""
    
    def generate_environment(self, hierarchy, plan, mode):
        """Gera o ambiente completo baseado no modo selecionado"""
        if mode == "unit":
            self._generate_unit_test_env(hierarchy, plan)
        else:
            self._generate_system_test_env(hierarchy, plan)
    
    def _generate_unit_test_env(self, hierarchy, plan):
        """Gera ambiente para testes unit√°rios"""
        # Implementa√ß√£o similar √† vers√£o anterior, mas usando:
        # - templates/unit/
        # - Configura√ß√µes do plano de verifica√ß√£o
        pass
    
    def _generate_system_test_env(self, hierarchy, plan):
        """Gera ambiente para testes sist√™micos"""
        context = {
            "hierarchy": hierarchy,
            "plan": plan,
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "top_name": hierarchy.top_module.name
        }
        
        # 1. Gera interfaces sist√™micas
        self._render_template(
            "system/integration/system_interface.sv.j2",
            f"{context['top_name']}_system_if.sv",
            context
        )
        
        # 2. Gera ambiente UVM
        self._render_template(
            "system/system_env.sv.j2",
            f"{context['top_name']}_system_env.sv",
            context
        )
        
        # 3. Gera verifica√ß√µes espec√≠ficas
        if plan.system_tests.interface_consistency:
            self._generate_interface_checks(context)
            
        if plan.system_tests.dataflow:
            self._generate_dataflow_checks(context)
            
        if plan.system_tests.performance:
            self._generate_performance_checks(context)
    
    def _generate_interface_checks(self, context):
        """Gera verifica√ß√µes de consist√™ncia de interfaces"""
        # Implementa√ß√£o espec√≠fica para verifica√ß√£o de protocolos
        pass
    
    def _generate_dataflow_checks(self, context):
        """Gera verifica√ß√µes de fluxo de dados"""
        # Implementa√ß√£o para verifica√ß√£o de fluxo atrav√©s do sistema
        pass

# ---------------------------------------------------------------
# Fun√ß√£o Principal
# ---------------------------------------------------------------
def main():
    root = tk.Tk()
    app = UVMAutoGenerator(root)
    root.mainloop()

if __name__ == "__main__":
    main()